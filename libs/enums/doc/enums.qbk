
[/
 / Copyright (c) 2010 Vicente J. Botet Escriba
 /
 / Distributed under the Boost Software License, Version 1.0. (See accompanying
 / file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 /]

[library Toward Boost.Enums
    [quickbook 1.5]
    [version 0.2.0]
    [authors [Botet Escriba, Vicente J.]]
    [copyright 2010-2011 Vicente J. Botet Escriba]
    [category Utilities]
    [id boost.enums]
    [dirname enums]
    [purpose C++0x scoped enums emulation]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[:['"C enumerations constitute a curiously half-baked concept."]]
[:[*Stroustrup ]]

[warning Enums is not a part of the Boost libraries.]

[/========================]
[section Overview]
[/========================]



[/====================================]
[heading How to Use This Documentation]
[/====================================]


This documentation makes use of the following naming and formatting conventions.

* Code is in `fixed width font` and is syntax-highlighted.
* Replaceable text that you will need to supply is in [~italics].
* If a name refers to a free function, it is specified like this:
  `free_function()`; that is, it is in code font and its name is followed by `()`   to indicate that it is a free function.
* If a name refers to a class template, it is specified like this:   `class_template<>`; that is, it is in code font and its name is followed by `<>`   to indicate that it is a class template.
* If a name refers to a function-like macro, it is specified like this: `MACRO()`;
  that is, it is uppercase in code font and its name is followed by `()` to   indicate that it is a function-like macro. Object-like macros appear without the   trailing `()`.
* Names that refer to /concepts/ in the generic programming sense are specified in CamelCase.

[note In addition, notes such as this one specify non-essential information that provides additional background or rationale.]

Finally, you can mentally add the following to any code fragments in this document:

    // Include all of the core Enums files
    #include <boost/enums.hpp>

    using namespace boost::enums;

[section Motivation]

The David E. Miller, Herb Sutter and Bjarne Stroustrup's proposal ([@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1891.pdf [*N1891: Strongly Typed Enums (revision 3)]] includes a clear motivation for "Strongly Typed Enums". On compilers not providing "Strongly Typed Enums" we can make a quite close emulation. This allows to write programs that are portable on compilers providing this feature natively and using the emulation on the others.

Kevlin Henney presents in [@http://www.two-sdg.demon.co.uk/curbralan/papers/FlagWaiving.pdf [*Flag Waiving]] a safe design for enum sets which is based on the association of an enumeration element and its position on the enumeration itself. This is found also in language as [@http://en.wikipedia.org/wiki/Enumerated_type#Ada [*Ada]], which defines attributes on enumerations like `first`, `last`, `succ`, `value`, `pos`, ... The same mapping can be used to implement arrays having an enumeration as index type and viewing enumerations as a range. This association has constant time complexity most of the times, as usual enumerations follows linear or logarithmic progressions.

A third feature that has been requested for a long time is the ability to convert an enum to an string and vice versa.

Examples of libraries that have tried to cope with some of these aspects are:


* [@http://www.boostpro.com/vault/index.php?action=downloadfile&filename=enum_rev4.6.zip&directory=& [@Boost.Enum]] by Frank Laub, takes care of scoping, underlying type, iteration and string conversions, but doesn't take care of avoiding implicit conversion and portability to C++0x scoped enums.
* This thread [@http://boost.2283326.n4.nabble.com/Smart-enum-td2604736.html Smart enums] and this one [@http://boost.2283326.n4.nabble.com/safe-assign-of-int-to-enum-td2556392.html#a2556400 safe assign of int to enum] are quite interesting. Unfortunately there were no concrete proposal.
* [@http://www.boostpro.com/vault/index.php?action=downloadfile&filename=benum_v1.zip&directory=&  [@Boost.SmartEnums]] has complex design to take care of iteration.
* [@http://www.boostpro.com/vault/index.php?action=downloadfile&filename=benum_v1.zip&directory=&  [@BEnum]].


There is also a lot of papers about these simple problems, well, not so simple to get it right. Just type on your preferred search engine a combination of the following words: C++, enum, strong, scoped, smart and safe and you will see. Next follows some I have read:

* [@http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Safe_Enum [*Type Safe Enum]] by Sumant Tambe defines a safe_enum mixing class which is similar to the enum_class class.
* [@http://www.eetimes.com/discussion/programming-pointers/4024556/Enumerations-Q--A [*Enumerations Q & A]]
    by Dan Saks.
* [@http://drdobbs.com/cpp/184401797 [*Enumerations]] by Herb Sutter and Jim Hyslop. 


There are also some lint tools that help in this concern.

* [@http://www.gimpel.com/html/strong.htm [*PC-lint/FlexeLint Strong Type Checking]] from Gimpel Software.


[endsect]
[/==================]
[section Description]
[/==================]


[*Boost.Enums] intends to provide a partial solution to the scoped enums problem ensuring a portable solution compatible with compilers supporting natively scoped enums or not. In addition provides a framework to view enumerations as ordinal types so we can define some specific and efficient enum containers.

[*Boost.Enums] is composed of the following parts:

* Scoped enums
* Ordinal enums
* Enum containers
* MPL enums
* String <-> Enum conversions

[heading Scoped enums]

The main features of scoped enums are 
* enumerators are in the scope of their enum
* enums have a defined underlying type

In addition scoped enum classes satisfies:

* enumerators and enums do not implicitly convert to int

The library includes:

* Some meta-functions and functions helping to write portable programs using scoped enum classes under compilers supporting them natively or by an emulation on the others.
* scoped enum classes with/without implicit conversion to the underlying type and with/without constructors.
* Some language-like macros helping to define scoped enums.


[heading Ordinal enums]

Ordinal enums are discrete types for which the enumerators have an associated position.

The library includes some functions and meta-functions: `first`, `last`, `pred`, `succ`, `pos`, `val`, `size`.

[heading Enum containers]

* `enum_array` indexed by an enumeration.
* `enum_set` using a bit for each element of an enumeration. 
* `enum_range` a run-time range view of an enumeration

[heading MPL enums]

* `enum_c`, a MPL type constant associated to an scoped enumeration.
* `enum_range_c`, a MPL sequence associated to an scoped enumeration.

[endsect]
[endsect]

[/==============================]
[section:users_guide Users' Guide]
[/==============================]

[/======================================]
[section:getting_started Getting Started]
[/======================================]

[/======================================]
[section:install Installing Boost.Enums]
[/======================================]

[/=================================]
[heading Getting Boost.Enums]
[/=================================]

You can get the last stable release of [*Boost.Enums] by downloading [^enums.zip] from the
[@http://www.boostpro.com/vault/index.php?action=downloadfile&filename=enums.zip&directory=Utilities& Boost Vault Utilities directory]

You can also access the latest (unstable?) state from the [@https://svn.boost.org/svn/boost/sandbox/enums Boost Sandbox].

[/=================================]
[heading Building Boost.Enums]
[/=================================]

There is no need to compile [*Boost.Enums], since it's a header only library. Just include your Boost header directory in your compiler include path.

[/=========================]
[heading Requirements]
[/=========================]


[*Boost.Enums] depends on Boost.Config and all libraries they depends on.

* [*Boost.Enums]/ScopedEnums depends on Boost.Assert, Boost.Conversion (configurable), Boost/StaticAssert, Boost.Preprocessor and all libraries they depends on.

* [*Boost.Enums]/OrdinalEnums depends on Boost.XXX and all libraries they depends on.

* [*Boost.Enums]/EnumContainers depends on Boost.Array, Boost.Exception, Boost.Iterator, Boost.Functions/Hash, Boost.Range, Boost.TypeTraits and all libraries they depends on.

* [*Boost.Enums]/MplEnums depends on Boost.MPL and all libraries they depends on.

* [*Boost.Enums]/StringsEnums depends on Boost.XXX and all libraries they depends on.


[/========================]
[heading Exceptions safety]
[/========================]

All functions in the library are exception-neutral and provide strong guarantee of exception safety as long as the underlying parameters provide it.

[/====================]
[heading Thread safety]
[/====================]

All functions in the library are thread-unsafe except when noted explicitly.

[/=======================]
[heading Tested compilers]
[/=======================]

The implementation will eventually work with most C++03 conforming compilers.
Current version has been tested on:

Windows with

* MSVC 10.0

Cygwin 1.7 with

* GCC 4.3.4

MinGW with

* GCC 4.4.0
* GCC 4.5.0
* GCC 4.5.0 C++0x
* GCC 4.6.0
* GCC 4.6.0 C++0x

Ubuntu 10.10

* GCC 4.4.5
* GCC 4.4.5 -std=c++0x
* GCC 4.5.1
* GCC 4.5.1 -std=c++0x
* clang 2.8

Darwin 10 - Snow Leopard 

* clang 1.6 
* GCC 4.2.1

[note Please let us know how this works on other platforms/compilers.]

[note Please send any questions, comments and bug reports to boost <at> lists <dot> boost <dot> org.]

[endsect]
[/=============================]
[section Hello World! ]
[/=============================]


[endsect]

[endsect]

[section:tutorial Tutorial]
[section:scoped Scoped Enums]

[section How to declare a scoped enum class?]

You can define the equivalent of 

  enum class EnumClass : unsigned char 
  {
    Enum0 = 0,
    Enum1,
    Enum2
  };
  
using the provided macros as follows

  BOOST_ENUM_CLASS_START(EnumClass, unsigned char) 
  {
    Enum0 = 0,
    Enum1,
    Enum2
  } BOOST_ENUM_CLASS_END(EnumClass, unsigned char)
  
Simple, isn't it?

[endsect]
[section How to use scoped enum and the associated literals?]

Scoped enums and the associated literals can be used as the C++0x counterparts in almost all the situations. There are some exception that will need some help from your part. We will see these cases later.


  EnumClass e;
  e = EnumClass::Enum1;
 
[endsect]
[section Are scoped enum classes convertible to the underlying type?]

Scoped enums classes are strong types and the conversion to the underlying type is not implicit. 

  unsigned char c = EnumClass::Enum0; // ERROR


If the compiler support Scoped Enums you can do it using explicit conversion.

  unsigned char c = (unsigned char)(e);

When the compiler doesn't support scoped enums you will need to use the `enums::underlying_value()` function to get explicitly the value. Of course the same function works as well when the compiler support Scoped Enums, for portability reasons you should use this function

  EnumClass e = EnumClass::Enum2;
  unsigned char c = enums::underlying_value(e);

[endsect]
[section How to define a scoped enum type?]

If you need an implicit conversion to the underlying type you could to use scoped enum types. Scoped enum types add implicit conversion to the underlying type. On compiler supporting Scoped enums they can be defined as follows


  enum EnumType : int 
  {
    Enum0 = 0,
    Enum1,
    Enum2
  };

Using the library macros this can be defined as follows:

  BOOST_ENUM_TYPE_START(EnumType, int) {
    Enum0 = 0,
    Enum1,
    Enum2
  } BOOST_ENUM_TYPE_END(EnumType, int)

  EnumType e = EnumType::Enum2;
  int i = e; //OK

[endsect]

[section Can these scoped enums be used inside unions?]

All this depends on your compiler. If the compiler support unrestricted unions, there is no problem. But in the opposite case, you will need to inhibit the constructor.

[section How to inhibit the constructors generation?]

You will need to use the `BOOST_ENUM_XXX_NO_CONS_END` macros to inhibit the constructor generation 

  BOOST_ENUM_TYPE_START(EnumType, int) {
    Enum0 = 0,
    Enum1,
    Enum2
  } BOOST_ENUM_TYPE_NO_CONS_END(EnumType, int)

The problem with removing the constructors is that we are unable to have default constructor and copy constructors syntax. So we will need to use a different syntax to get portable programs.

[endsect]
[section How to replace the default constructor?]

The following compiles but the enum value is undefined

  {
    EnumClass e ;
  }

You need to state explicitly that you want the default value, which is 0.

  { // defaults to 0
    EnumClass e = EnumClass();
    BOOST_TEST(e==EnumClass::Enum0);
  }

If you have inhibited the constructors, the preceding code could fail as the default constructor doesn't set the value to 0 when emulation is used. The library provides a function that creates scoped enums instances initialized with the default value, i.e., 0.

  { // defaults to the enum default
    EnumClass e = default_value<EnumClass>();
    BOOST_TEST(e==EnumClass::Enum0);
  }

[endsect]
[section How to replace the copy constructor?]

The following fails to compile if the emulation doesn't adds the needed constructors:

  { // copy constructor emulation
    EnumClass e(EnumClass::Enum2);  // COMPILE ERROR HERE
  }

The library provides an assignment operator that allows to have the equivalent as:

  { // copy constructor emulation
    EnumClass e=EnumClass::Enum2;
    BOOST_TEST(e==EnumClass::Enum2);
  }


[endsect]

[endsect]
[section How to use scoped enums in switch statements?]

With scoped enum types the following works as there is an implicit conversion from the emulation to the enum type.

The following fails to compile as implicit conversion to the enum type is not define:
 
  const char* c_str(EnumType e)
  {
      switch (e) // conversion from EnumType to native_type<EnumType>::type
      {
      case EnumType::Enum0 :   return("EnumType::Enum0");
      case EnumType::Enum1:    return("EnumType::Enum1");
      case EnumType::Enum2 :   return("EnumType::Enum2");
      default:
        return("EnumClass::???");
      }
  }

However, with scoped enum classes the following fails to compile as implicit conversion to the enum type is not define:
 
  const char* c_str(EnumClass e)
  {
      switch (e) // COMPILE ERROR HERE
      {
      case EnumClass::Enum0 :   return("EnumClass::Enum0");
      case EnumClass::Enum1:    return("EnumClass::Enum1");
      case EnumClass::Enum2 :   return("EnumClass::Enum2");
      default:
        return("EnumClass::???");
      }
  }

The library provides a function `native_value()` that makes this conversion explicitly, i.e., return the native enum in a portable way.

  const char* c_str(EnumClass e)
  {
      switch (boost::enums::native_value(e))
      {
      case EnumClass::Enum0 :   return("EnumClass::Enum0");
      case EnumClass::Enum1:    return("EnumClass::Enum1");
      case EnumClass::Enum2 :   return("EnumClass::Enum2");
      default:
        return("EnumClass::???");
      }
  }

[endsect]
[section How to use scoped enums as non type template parameters?]

The following fails to compile as the emulation is not a built-in type:
 
  template <EnumClass e>
  struct ex;

The library provides a meta-function `native_type<>` that return the native enum type in a portable way.

  template <enums::native_type<EnumClass>::type e>
  struct ex;

[endsect]


[section Can scoped enums be used in bitfields?]

The C++ scoped enums can be used in bitfields declarations

  struct S 
  {
    EnumClass i : 2;
    int j : 6;
  };

As the emulation is not a built-in type this cannot compile in a portable way. [*Boost.Enums] has no workaround to this problem, but fortunately we could use Boost.Bitfield library (when available) to emulate the whole structure cottoning scoped enums bitfields as follows

  typedef bitfields<
    member<EnumClass,2>,
    member<int,6>
  > S;

[endsect]
[section Where the macro can be placed?]

The macro need to define the scoped enum type on the user namespace, so it seems natural to do the following

  namespace UNS
  {
    BOOST_ENUM_TYPE_START(EnumType, int) {
      Enum0 = 0,
      Enum1,
      Enum2
    } BOOST_ENUM_TYPE_END(EnumType, int)
  }

The problem is that the macro needs to generate some specializations on the `boost::enums` namespace. There are two solutions to this problem:

* use a different macro `BOOST_ENUMS_SPECIALIZATIONS()` to make the specializations

  namespace UNS
  {
    BOOST_ENUM_TYPE_START(EnumType, int) {
      Enum0 = 0,
      Enum1,
      Enum2
    } BOOST_ENUM_TYPE_END(EnumType, int)
  }
  BOOST_ENUMS_SPECIALIZATIONS(EnumType, int)


* use the macro outside any namespace and pass the sequence of namespaces as part of the first parameter

    BOOST_ENUM_TYPE_START( (UNS)(EnumType), int) {
      Enum0 = 0,
      Enum1,
      Enum2
    } BOOST_ENUM_TYPE_END( (UNS)(EnumType), int)

The option retained by the library is the second one, as you will see when taking in account the ordinal enums, the duplication will be no limited to the enum type and underlying type, but also to the enum literals as well.

Fortunately, when the user doesn't needs to define the scoped enum inside a specific namespace the use of the PP sequence is not needed and 

    BOOST_ENUM_TYPE_START(EnumType, int) {
      Enum0 = 0,
      Enum1,
      Enum2
    } BOOST_ENUM_TYPE_END(EnumType, int)

works as well.

[endsect]
[endsect]

[section:ordinal Ordinal Enums]

While C++0x provides scoped enums, the standard doesn't see an enum as an ordinal type. Language as Pascal and Ada had defined since the beginning attributes that allows to map an enumeration to a continuous range `0..N-1`, so it can be used in for statements and as index of an array.

[section:meta Size, Position and Value]

The needed informations are 

* `size`: the number of elements in the enum type.
* `pos`: the position relative of an element in the enum type.
* `val`: the element in the enum type at a given position.

The compiler could have these informations, but in the absence the user will need to add them explicitly.

[*Boost.Enums] provides a framework that allows to add these meta-information and use them in a uniform way at compile-time and run-time.

The library provides the declaration of the meta-function that will need to be specialized for each enumeration,

  boost::enums::meta::size<EC>::value
  boost::enums::meta::pos<EC, V>::value
  boost::enums::meta::val<EC, P>::value

and a uniform run-time interface.

  boost::enums::size<EC>(e);
  boost::enums::pos(e);
  boost::enums::val<EC>(p);

An example of specialization follows:

  namespace boost {
    namespace enums {
      namespace meta {

        template <>
        struct size<EC3>
        {
          BOOST_STATIC_CONSTEXPR std::size_t value=3;
        };
        template <>
        struct pos<EC3, EC3::Enum0>
        {
          BOOST_STATIC_CONSTEXPR std::size_t value = 0;
        };
        template <>
        struct pos<EC3, EC3::Enum1>
        {
          BOOST_STATIC_CONSTEXPR std::size_t value = 1;
        };
        template <>
        struct pos<EC3, EC3::Enum2>
        {
          BOOST_STATIC_CONSTEXPR std::size_t value = 2;
        };

        template <>
        struct val<EC3, 0>
        {
          BOOST_STATIC_CONSTEXPR native_type<EC3>::type value = EC3::Enum0;
        };
        template <>
        struct val<EC3, 1>
        {
          BOOST_STATIC_CONSTEXPR native_type<EC3>::type value = EC3::Enum1;
        };
        template <>
        struct val<EC3, 2>
        {
          BOOST_STATIC_CONSTEXPR native_type<EC3>::type value = EC3::Enum2;
        };
        template <>
        struct enum_traits<EC3> : linear_enum_traiter<EC3>
        {
        };
      } // namespace meta
    }
  }


As this is quite cumbersome, the library provides macros that will generate all this stuff for you. Unfortunately there is no way to preserve the syntax of the scoped enums and in addition the generated code must be in different namespaces.

There are two macro forms: one using PP sequences and other with variadic macros.

  BOOST_ENUM((NS1)(NSB)(Enum), 
    ( (Enum0) (0) )
    ( (Enum1) )
    ( (Enum2) )
  )

The PP sequence contains itself a PP sequence that has as mandatory first element, the enum literal, and the second optional element used to give an explicit enum value.

The same example with variadic macros results in

  BOOST_ENUM_VN(Enum, 
    (Enum0) (0),
    Enum1,
    Enum2,
  )

The preceding macros are applied to C/C++98 enums. As we can be interested in mixing scoped and ordinal enums the library provides the respective macros. To be brief only the PP sequence version is given here. For scoped enum classes use `BOOST_ENUM_CLASS()`

  BOOST_ENUM_CLASS(EnumClass, int, 
    ( (Enum0) (0) )
    ( (Enum1) )
    ( (Enum2) )
  )

For scoped enum types use `BOOST_ENUM_TYPE()`

  BOOST_ENUM_TYPE(EnumType, int, 
    ( (Enum0) (0) )
    ( (Enum1) )
    ( (Enum2) )
  )

As you can see these macros have the advantage to avoid the duplication of the enum name and the underlaying type that we had with the scoped enum macros.

[endsect]
[section:aux First, Last, Succ and Pred]

Once these meta-informations are given, the user can retrieve in a uniform way the first, last, successor and predecessor.

  boost::enums::meta::first<EC>::value
  boost::enums::meta::last<EC>::value
  boost::enums::meta::pred<EC, V>::value
  boost::enums::meta::succ<EC, v>::value

and a uniform run-time interface.

  boost::enums::first<EC>();
  boost::enums::last<EC>();
  boost::enums::pred(e);
  boost::enums::succ(e);


[endsect]
[endsect]
[section:cont Enum Containers]
[section:set Enum Set]

One of the major motivations for the preceding functions and meta-fuction was to be able to define a generic enum set class based on the work of Kevlin Henney.

The `enum_set<EC>` class has as parameter an enum, enum class or enum type and provides the same interface as `std::bitset<N>` but replacing the index by the enum. As Kevlin showed this give to the user a more safer interface than using bit mask directly.


[endsect]

[section:array Enum Arrays]

As we are able to map the enum to a range `0..N-1` we can define an enum array class based on the `std::array<T,N>` class that use instead an enum as index, `enum_array<T,E>`.

[endsect]


[section:range Enum Range]

We will not stop here. We can view the enumeration as a range, so we can iterate over all the elements of an enumeration. The class `enum_range<E>` provides this view, so for example we can do

  std::for_each(enum_range<E>(), p);


[endsect]
[endsect]

[section:mpl MPL Enums]
[section:enum_c MPL constants]

Boost.MPL provides integral constants, but we cannot use them with enums as the successor and predecessor have different semantics.

We have created a new MPL tag enum_tag_c and an enumeration constant enum_c so we can specialize the specific behavior of MPL sequences for static enumerations.

[endsect]

[section:range_c MPL Enum sequences]

We can view an enumeration as an MPL sequence. Based on the `integer_range_c<>` class, the `enum_range_c<EC>` allows to visit at compile time all the elements of an enumeration.

[endsect]

[section:sub_type What about reducing the literals of an enumeration?]

The typical example of enumeration sub-typing is the days of the week and the working days. In Ada we can do

  type Day_Of_Week is (Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday);
 
  subtype Working_Day is range Monday .. Friday;

Given the following definition of `Day_Of_Week` 

  BOOST_ENUMS_CLASS(Day_Of_Week, int, Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday);
 
we can define the sub-type `Working_Day` using the `enum_sub_range<>` template class

  typedef enums::enum_sub_range<Day_Of_Week, Monday, Friday> Working_Day;

`Working_Day` is implicitly convertible to `Day_Of_Week` and is explicitly constructible from vDay_Of_Week` with a run-time checking of course.

When the sub-type enumeration literals are not consecutive we need a generic way to state whether it belongs or not. A predicate seems to be the good compromise. Note that this is quite related to the constraint library.

  typedef enums::enum_sub_type<Day_Of_Week, P> Working_Day;

These enumeration sub-types `enum_sub_range<>` and `enum_sub_type<>` can be used as well as index of `enum_array<>` and as type of `enum_set<>` and `enum_range<>`.

 

[endsect]


[endsect]

[section:str String conversions]

One of the more requested features to enumerations is to be able to convert to a string in a uniform way.

We can define explicitly this conversion as done previously:

  const char* c_str(EnumClass e)
  {
      switch (boost::enums::native_value(e))
      {
      case EnumClass::Enum0 :   return("Enum0");
      case EnumClass::Enum1:    return("Enum1");
      case EnumClass::Enum2 :   return("Enum2");
      default:
        return("EnumClass::???");
      }
  }

The advantage of the explicit conversion is that we can choose the string literal associated to the enum literal. While this is quite simple we can extend the macros to take care of a 3rd element on the PP sequence, i.e., the string representation.

  BOOST_ENUMS_CLASS_VM(RGB, int, 
        (Red)   () (Rojo), 
        (Green) () (Verde), 
        (Blue)  () (Azul)
  );

We need a second empty `()` token to signal the macros that the numeration must be done implicitly.

With this definition for `RGB` the following

  RGB c = RGB::Blue;
  std::cout << enums::c_str(e) << " = " << enums::underlying_value(e) << std::endl;

will print

  Azul = 2


When the 3rd token is empty or missing, the macro use the enum literal as string.

  BOOST_ENUMS_CLASS_VM(RGB, int, Red, Green, Blue);





[endsect]

[endsect]

[section:examples Examples]

[section:color Implicit conversion to an integer]

This show the example in [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf [*N2347: Strongly Typed Enums (revision 3)]] section 2.1. Implicit conversion to an integer.

  #include <boost/enums/emulation.hpp>

  BOOST_ENUM_CLASS_START(Color, int) 
  { Red, Orange, Yellow, Green, Blue, Violet };
  BOOST_ENUM_CLASS_END(Color, int)
  BOOST_ENUMS_SPECIALIZATIONS(Color, int)

  BOOST_ENUM_CLASS_START(Alert, int) 
  { Green, Yellow, Red };
  BOOST_ENUM_CLASS_END(Alert, int)
  BOOST_ENUMS_SPECIALIZATIONS(Alert, int)

  void compile_fail() { 
    Alert a = Alert::Green; 
    bool armWeapons = ( a >= Color::Yellow ); // error: cannot compare and Alert to a Color
  }


[endsect]
[section:version Predictable and specifiable space]


This show the example in [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf [*N2347: Strongly Typed Enums (revision 3)]] section 2.2.1.Predictable and specifiable space.

  #include <boost/enums/emulation.hpp>
  #include <stdint.h>

  BOOST_ENUM_CLASS_START(Version, uint8_t)
  { Ver1 = 1, Ver2 = 2 }
  BOOST_ENUM_CLASS_END(Version, uint8_t)
  BOOST_ENUMS_SPECIALIZATIONS(Version, uint8_t)

  struct Packet {
    Version ver;	// ok, portable 
    Version getVersion() const { return ver; }
  };

[endsect]
[section:unsigned Predictable/specifiable type (notably signedness)]

Unfortunately the emulation can not take care of issue with the enumerators signed in [@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf [*N2347: Strongly Typed Enums (revision 3)]] section 2.2.2. Predictable/specifiable type (notably signedness)

  #include <boost/enums/emulation.hpp>
  #include <iostream>

  BOOST_ENUM_TYPE_START(E, unsigned long) 
  {  E1 = 1, E2 = 2, Ebig = 0xFFFFFFF0U }
  BOOST_ENUM_TYPE_END(E, unsigned long)
  BOOST_ENUMS_SPECIALIZATIONS(E, unsigned long)


  int main() { 
    std::cout << sizeof( E ) << std::endl; 
    std::cout << "Ebig = " << E::Ebig << std::endl; 
    std::cout << "E1 ? -1 =\t" << ( E::E1 < -1 ? "less" : E::E1 > -1 ? "greater" : "equal" ) << std::endl; 
    std::cout << "Ebig ? -1 =\t" << ( E::Ebig < -1 ? "less" : E::Ebig > -1 ? "greater" : "equal" ) << std::endl;
    return 0;
  }



[endsect]
[section:aligned aligned]


[endsect]
[section:cv_status cv_status]


[endsect]
[endsect]



[section:ext_references External Resources]

[variablelist
[
    [[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf [*N2347: Strongly Typed Enums (revision 3)]]]
    [Alistair Meredith]
]

[
    [[@http://www.gimpel.com/html/strong.htm [*PC-lint/FlexeLint Strong Type Checking]]]
    [Gimpel Software]
]

[
    [[@http://drdobbs.com/cpp/184401797 [*Enumerations]]]
    [Herb Sutter and Jim Hyslop ]
]

[
    [[@http://www.eetimes.com/discussion/programming-pointers/4024556/Enumerations-Q--A [*Enumerations Q & A]]]
    [Dan Saks]
]

]

[endsect]

[endsect]

[section Reference]

[xinclude top_ref.xml]
[xinclude scoped_enums_ref.xml]
[xinclude ordinal_enums_ref.xml]
[xinclude enums_containers_ref.xml]
[xinclude mpl_enums_ref.xml]
[xinclude macros.xml]

[/xinclude string_enums_conversion_ref.xml]


[endsect]

[/=================]
[section Appendices]
[/=================]

[section:history Appendix A: History]

[section [*Version 0.2.0, Mars 23, 2011] ]

[*New Features:]

* Make more coherent the meta-functions and functions.
  * Added underlying_value.
  * Added scoping_type.
  * enum_type renamed native_type
  * Added is_enum.
* Added ordinal enums: first, last, red, succ, pos, val, size functions and meta-functions.
* Added enum containers:
  * enum_type_cons/no_cons and enum_class_cons/no_cons classes.
  * Added enum_array indexed by an enumeration.
  * Added enum_set using a bit for each element of a enumeration.

* Added enum_range. a run-time range view of an enumeration
* Added enum_range_c, a MPL sequence associated to an enumeration.

* Added more macros
  * user namespace aware macros.
  * PP sequence macros to cope with ordinal enums.  
  * Conversion to and from strings generation.


[endsect]
[section [*Version 0.1.0, Feb 27, 2011] ]

Initial version committed on the sandbox

[*Features:]

* Some language-like macros helping to define scoped enum classes.
* Some meta-functions and functions helping to write portable programs using scoped enum classes under compilers supporting them natively or by an emulation on the others.

[endsect]
[endsect]

[section:rationale Appendix B: Design Rationale]

[heading How the macros generated code looks like?]

Nest follows the skeleton of the emulation class

    class EC {                    
    public:                                         
      enum type { <LIST_OF_ENUM_LITERALS> };                                             
      typedef UT underlying_type;                   
    private:                                        
      underlying_type val_;                         
    public:
      // constructors if requested
      EC();
      EC(type v);
      // implicit conversion for scoped enum type only
      operator underlying_type();
      operator type();
      // explicit conversion for scoped enum if available and no need for the implicit ones
      explicit operator underlying_type();
      explicit operator type();
      // assignment
      EC& operator=(EC rhs);
      // assignment from enum literals
      EC& operator=(type rhs);
      // workaround in case there are no constructors       
      static EC default_value();                             
      static EC convert_to(underlying_type v);               
      static EC convert_to(type v);
      // explicit conversion in case explicit conversions are not available        
      type native_value() const;                                      
      underlying_type underlying_value() const;                                      
      // comparison operators
      friend bool operator==(EC lhs, EC rhs);
      friend bool operator==(type lhs, EC rhs);
      friend bool operator==(EC lhs, type rhs);
      // ...
      // friend conversions to follow the Boost.Conversion protocol
      friend EC convert_to(underlying_type v, boost::dummy::type_tag<EC> const&);
      friend EC convert_to(type v, boost::dummy::type_tag<EC> const&);          
      friend underlying_type convert_to(EC v, boost::dummy::type_tag<underlying_type> const&);        
      friend type convert_to(EC v, boost::dummy::type_tag<type> const&);                                                                         
    };                                                      

[heading What about using nested static constants instead of enum literals?]




[heading Why an alternative design for the SCOPED ENUM macros?]

Beman's macros are really simple and provide an already useful abstraction. 

The major liabilities of the Beman's design is that the emulation is unable to:

* Avoid the overloading ambiguity as the scoped enum is convertible to int. 
* Forbid the implicit conversion to the underlying type, that is, implement scoped enum classes. 
* Specify the underlying type. 

We can say that the Beman's approach implements only scoped enum literals.

Beman's design has also advantages. The enum type is a real enum, i.e., a built-in that can be used quasi-transparently in:

* unions, 
* bitfields, 
* switches and 
* template parameters.

So I would say that both designs can be used depending on the context.
 
[heading Using ADL to specialize the meta-information functions]

The meta-functions need to be defined as specializations of the library classes. For the free functions we have two alternatives:

* Use of overloading and ADL
* Use of a specific enums function which delegates to a specialized enum traits class


The first option seems more attractive as the user doesn't need to use the namespace boost::enemas:: to have access to the function, at least for the functions having the enumeration as parameter. Unfortunately there are some functions that don't have the enumeration as parameter, in particular the val() function that need to be called giving the enumeration as template parameter, val<E>(p). 

There are some function that have a convenient default implementation, first, last, pred and succ. These functions will leave in the boost::enums namespace.  

As always the best could be to mix in a single design the best of both approaches and follow the design of the Boost.Swap and Boost.Conversion libraries, that is, defines the functions at the boost::enums level, which will call using ADL the free function.

[heading Does the enum_c class need the additional enum emulation class as parameter?]

Initially this parameter was not present, and was deduced using a trait scoping_type class. The problem with this trait class is that it forces to make the specialization on the correct namespace boost::enums, so we cannot include it on the macro, as the scoped enum could be in a specific namespace.

For compilers that support scoped enums but that doesn't define the underlying_type the first versions of the library generated this specialization on a specific macro, BOOST_ENUMS_SPECIALIZATIONS  

[endsect]

[section:implementation Appendix C: Implementation Notes]



[heading Performance comparison between the use of the emulated enums and direct use of ints]

[endsect]
[section:acknowledgements Appendix D: Acknowledgements]

Thanks to Beman Dawes for opening the initial discussion. Daniel James for giving the idea of the alternative implementation and to Matt Calabrese for his insightful comments on the ML. This library will never be created without the exchanges they made on the ML (see [@http://boost.2283326.n4.nabble.com/Boost-Dev-f2600599.html here]).

[endsect]
[section:tests  Appendix E: Tests]

[section scoped_enum_class]

[table Constructors and Assignment
    [[Name]                             [kind]      [Description]                                   [Result]]
]

[endsect]
[section scoped_enum_type]

[table Constructors and Assignment
    [[Name]                             [kind]      [Description]                                   [Result]]
]

[endsect]
[section scoped_enum_no_cons_class]

[table Constructors and Assignment
    [[Name]                             [kind]      [Description]                                   [Result]]
]

[endsect]
[section scoped_enum_no_cons_type]

[table Constructors and Assignment
    [[Name]                             [kind]      [Description]                                   [Result]]
]

[endsect]

[endsect]

[/=====================================]
[section:todo  Appendix F: Future plans]
[/=====================================]

[heading Tasks to do before review]

* Remove assertions and make a uniform use of exceptions.
* Complete the doc with more user-land examples.
* Add the hello world example.
* Add more tests.

[heading For later releases]

* Add enum hash functions for ordinal enums, so they can be used efficiently with unordered associative containers.
* Specialize enum_array, enum_set and enum_range for enum_sub_range.
* Define the variadic macros.  
* Add enum_sub_type.
* Other ideas?

[endsect]
[endsect]

[section:indexes Indexes]

[? enable_index
'''
  <index/>

  <index type="function_name">
  <title>Function Index</title>
  </index>
  
  <index type="class_name">
  <title>Class Index</title>
  </index>
  
  <index type="typedef_name">
  <title>Typedef Index</title>
  </index>
'''
]
[endsect] [/section:indexes Indexes]


